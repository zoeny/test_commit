# -*- coding: utf-8 -*-
'''
@project: Pycharm_project
@Time : 2019/6/26 10:41
@month : 六月
@Author : mhm
@FileName: 1、爬楼梯.py
@Software: PyCharm
'''
'''
题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。
定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。
第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。
考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 
空间复杂度优化为 O(1) 复杂度。

将大问题分解成小问题，然后合并小问题的解，进而得到大问题的解。实际上就是解决了小问题之后，把小问题的解存储成一个表，当要使用的时候就查表，直接调用之前的到的结果。
所有递归的方法都可以转化成非递归的方法，也就是动态规划
通过把大问题分解为相对简单的子问题的方式求解复杂问题的方法。适用于有重叠子问题和最优子结构性质的问题
动态规划和分治法的思想很类似，都是把化大为小，逐个击破。
区别在于分治法分成的小问题都是相互独立的，需采用递归的做法，而动态规划分成的小问题之间有一定的联系，可以通过查找来直接使用。
'''

'''
思路：
1.由题目我们可以知道，当你爬到第n个楼梯的时候，你有两种选择，第一种是从第n-1个楼梯上走1个楼梯，第二种是从第n-2个楼梯上走2个楼梯.因此我们可以得到这样的一个式子：f(n)=f(n-1)+f(n-2)。
2.所以我们可以定义一个长度为n+1的数组，用来存放不同的数字相对应的解决方案，这里要注意的是当楼梯长度等于0或者1 的时候我们都看作是只有一种走法。
'''
# 动态规划方法
def climbStairs(n):
    current = [0]*(n+1)
    current[0] = 1
    current[1] = 1
    for i in range(2,n+1):
        current[i] = current[i-1]+current[i-2]
    return current[n]

# 递归方法
def climbStairs1(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    else:
        s1 = climbStairs1(n-1)
        s2 = climbStairs1(n-2)
        return s1+s2

print(climbStairs(6))
